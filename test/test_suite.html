<!DOCTYPE html>
<html>
<head>
  <title>XSLT Polyfill Test Runner</title>
<style>
  body {
    font-family: sans-serif;
  }
  table {
    border-collapse: collapse;
    width: auto;
  }
  th, td {
    border: 1px solid #ccc;
    padding: 4px;
    text-align: left;
  }
  th {
    background-color: #f2f2f2;
  }
  iframe {
    height: 2.2em;
    width: 100px;
    border: 0;
  }
</style>
</head>
<body>
  <h1>XSLT Polyfill Test Runner</h1>
  <div>
    <select id="mode">
      <option value="native">Run with Native Browser Feature</option>
      <option value="source">Run with Polyfill (Source)</option>
      <option value="minified">Run with Polyfill (Minified)</option>
    </select>
    <button id="go">Go</button>
  </div>
  <table id="results">
    <thead>
      <tr>
        <th>Test Case</th>
        <th>Output</th>
      </tr>
    </thead>
    <tbody>
    </tbody>
    <tfoot>
      <tr id="stats-row" style="font-weight: bold; background-color: #f2f2f2;">
        <td id="stats-cell">0 PASS, 0 FAIL</td>
        <td></td>
      </tr>
    </tfoot>
  </table>
  <p style="font-size: 0.7em; color: #666;">
    Direct test links:
    <a href="?autorun=native">native</a>,
    <a href="?autorun=source">source</a>,
    <a href="?autorun=minified">minified</a>
  </p>
</body>
</html>

<script>
  let passCount = 0;
  let failCount = 0;
  function updateStats() {
    const statsCell = document.getElementById('stats-cell');
    if (statsCell) {
      statsCell.textContent = `${passCount} PASS, ${failCount} FAIL`;
    }
  }

  function addTestResult(name, iframe, url) {
    const row = document.createElement('tr');
    const nameCell = document.createElement('td');
    nameCell.textContent = name + ' ';
    const link = document.createElement('a');
    link.href = url;
    link.target = '_blank';
    link.title = 'Open test file in new tab';
    link.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="vertical-align: middle;"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg>';
    nameCell.appendChild(link);
    row.appendChild(nameCell);
    const outputCell = document.createElement('td');
    outputCell.appendChild(iframe);
    row.appendChild(outputCell);
    document.getElementById('results').querySelector('tbody').appendChild(row);

    let counted = false;
    const check = () => {
      if (counted) return;
      try {
        const doc = iframe.contentDocument || iframe.contentWindow.document;
        if (!doc || !doc.documentElement) return;
        const text = (doc.body ? (doc.body.innerText || doc.body.textContent) : "") + " " + doc.documentElement.textContent;
        const upperText = text.toUpperCase();
        if (upperText.includes('PASS')) {
          counted = true;
          passCount++;
          updateStats();
          return true;
        } else if (upperText.includes('FAIL')) {
          counted = true;
          failCount++;
          updateStats();
          return true;
        }
      } catch (e) {
        // Continue polling if there's an error (e.g. document not ready)
      }
      return false;
    };

    iframe.addEventListener('load', () => {
      if (check()) return;
      const interval = setInterval(() => {
        if (check()) clearInterval(interval);
      }, 100);
      setTimeout(() => {
        clearInterval(interval);
        if (!counted) {
          counted = true;
          failCount++;
          updateStats();
        }
      }, 10000);
    });
    iframe.src = url;
  }
  function assert(cond,msg) {
    msg = msg || "Error";
    if (!cond) {
      document.documentElement.innerHTML = msg;
      throw new Error(msg);
    }
  }

  function runTest(testCase, mode) {
    const iframe = document.createElement('iframe');
    let url = testCase.html ? testCase.html : testCase.xml;
    return {iframe, url};
  }

  let nativeSupported = ('XSLTProcessor' in window) && window.XSLTProcessor.toString().includes('native code');
  if (nativeSupported) {
    try {
      new XSLTProcessor();
    } catch {
      nativeSupported = false;
    }
  }
  const modeElement = document.getElementById('mode')
  function runTests(testCases) {
    passCount = 0;
    failCount = 0;
    updateStats();
    document.getElementById('results').querySelector('tbody').innerHTML = '';
    const mode = modeElement.value;
    for (const testCase of testCases) {
      const {iframe,url} = runTest(testCase, mode);
      addTestResult(testCase.name, iframe, url);
    }
  }

  if (nativeSupported) {
    modeElement.selectedIndex = 0; // Native by default
    const msg = " (Native feature ENABLED!)";
    modeElement.options[1].textContent += msg;
    modeElement.options[2].textContent += msg;
  } else {
    modeElement.selectedIndex = 2; // Minified by default
    modeElement.options[0].textContent += " (NOT supported!)";
  }

  async function loadTestsAndRun() {
    const response = await fetch('generated/file_list.json');
    const allTestCases = await response.json();
    const mode = modeElement.value;
    const testCases = allTestCases.map(tc => {
        const testCase = { name: tc.name };
        if (tc.xml) {
            testCase.xml = tc.xml.replace('{{MODE}}', mode);
        }
        if (tc.xsl) {
            testCase.xsl = tc.xsl.replace('{{MODE}}', mode);
        }
        if (tc.html) {
            testCase.html = tc.html.replace('{{MODE}}', mode);
        }
        return testCase;
    });

    runTests(testCases);
  }

  document.getElementById('go').addEventListener('click', loadTestsAndRun);

  const urlParams = new URLSearchParams(window.location.search);
  const autorun = urlParams.get('autorun');
  if (autorun === 'source' || autorun === 'native' || autorun === 'minified') {
    modeElement.value = autorun;
    loadTestsAndRun();
  }
</script>
